{"./":{"url":"./","title":"Introduction","keywords":"","body":"IntroductionGo!!!Introduction https://www.bilibili.com/video/BV1PW411r7iP Go!!! 导航:课件大全 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。 ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 ZooKeeper包含一个简单的原语集，提供Java和C的接口。 ZooKeeper代码版本中，提供了分布式独享锁、选举、队列的接口，代码在$zookeeper_home\\src\\recipes。其中分布锁和队列有Java和C两个版本，选举只有Java版本。（概述图片来源：）new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-07-01 14:17:30 "},"meite/01_基于Zookeeper实现服务注册与发现/":{"url":"meite/01_基于Zookeeper实现服务注册与发现/","title":"01_基于Zookeeper实现服务注册与发现","keywords":"","body":"01.基于Zookeeper实现动态负载均衡课程介绍.mp402.Zookeeper实际案例中的应用场景.mp403.Zookeeper基本的实现的特征.mp404.基于linux环境安装Zookeeper.mp4\\Z****ookeeper****单机****版本**\\L****inux****环境****安装Zookeeper**\\核心相关****命令**05.注意安装Zookeeper前安装Jdk环境.mp406.Java语言客户端连接Zookeeper.mp407.Countdown计算器优化ZK代码.mp408.Zookeeper四种节点类型.mp409.Zookeeper节点ACL权限控制.mp410.使用Zookeeper实现服务注册.mp411.使用Zookeeper实现服务发现.mp401.基于Zookeeper实现动态负载均衡课程介绍.mp4 02.Zookeeper实际案例中的应用场景.mp4 zk - 分布式领域中的协调者 zk应用场景 ： 分布式锁 （redis或者zk） Dubbo服务注册（zk） 分布式配置中心 disconfig（百度的一个框架， 它吧它的配置信息放到了zk上了） 分布式消息中间件 发布订阅（事件通知） Master 选举（zk节点是唯一的） zk之所以能够帮我们解决这些问题，是离不开zk的特性： Zookeeper的特性： 类似文件系统 / /mayikt/ /mayitk/s0 ·分布式Zookeeper快速入门 .什么是Zookeeper. 官方文档上这么解释zookeeper，它是一个分布式服务框架，是Apache Hadoop 的一个子项目，它主要是用来解决分布式应用中经常遇到的一些数据管理问题，如:统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。+ 上面的解释有点抽象，简单来说zookeeper=文件系统+监听通知机制 03.Zookeeper基本的实现的特征.mp4 。 基本特性: 定义的节点包含节点名称和节点内容 ,定义的节点名称是不允许有重复的; 每个节点都可以设置对应的值 最重要的特性: 节点的路径不允许重复,否则就违反了幂等性原则了 事件通知 最后总结zk特征: 节点名称和节点value，路径必须保证是唯一，不允许重复。 每个节点都会有事件通知，当节点发生任何变化都可以获取信息; 04.基于linux环境安装Zookeeper.mp4 \\Z****ookeeper****单机****版本** \\L****inux****环境****安装Zookeeper** 1.解压zk压缩包 tar -zxvf zookeeper-3.4.14.tar.gz \\2. 进入到zk目录 cd zookeeper-3.4.14 3.在zk目录中创建data和logs文件夹 mkdir data mkdir logs 4.进入到conf目录，修改文件名称 mv zoo_sample.cfg zoo.cfg vi zoo.cfg dataDir =/usr/local/zookeeper-3.4.14/data dataLogDir=/usr/local/zookeeper-3.4.14/logs 5.启动zk ./zkServer.sh start ./zkServer.sh status 单机启动成功 \\核心相关****命令** service keepalived start service keepalived stop systemctl stop firewalld zk 的工具 注意：在安装Zk的时候提前安装好jdk环境 建议java8以上 05.注意安装Zookeeper前安装Jdk环境.mp4 要安装jdk环境,配置环境变量 否则会报错 06.Java语言客户端连接Zookeeper.mp4 package com.mayikt.zk; import org.apache.zookeeper.*; import java.io.IOException; /** * ClassName: Test001 * Description: Test001 * Date: 2021-07-01 15:58 * * * @author yufengming * @version 产品版本信息 2021-07-01 15:58 yufengming(victorefengming.gitee.io) 新建 * @project mayikt_zk * @package com.mayikt.zk * @email victorfengming@163.com * * 修改记录 */ public class Test001 { // * 参数1. 链接地址 private static final String ADDRES = \"116.62.194.162:2181\"; // * 参数2. zk超时事件 private static final int TIMEOUT = 5000; // * 参数3. 事件通知 // public static void main(String[] args) throws IOException, KeeperException, InterruptedException { // zk 核心节点 + 事件通知 // 节点路径 和节点 value /** * 参数1. 链接地址 * 参数2. zk超时事件 * 参数3. 事件通知 */ // 1. 创建 zk链接 ZooKeeper zooKeeper = new ZooKeeper(ADDRES, TIMEOUT, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { Event.KeeperState state = watchedEvent.getState(); if (state == Event.KeeperState.SyncConnected) { System.out.println(\"链接成功!!!\"); } } }); // 创建我门的节点 // 参数1 路径名称 // 参数2 节点value // 参数3. 节点权限 acl OPEN_ACL_UNSAFE 开放权限 // 参数4 节点类型 临时和永久 String s = zooKeeper.create(\"/mayikt\", \"mayikt\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); System.out.println(s); // } } 这里可以利用java8新特性,来利用lambda表达式进行改进 运行 07.Countdown计算器优化ZK代码.mp4 之前的写法有bug 举个例子:如果我zk没有链接成功 那么 就 就 后面就报错了 package com.mayikt.zk; import org.apache.zookeeper.*; import java.io.IOException; import java.util.concurrent.CountDownLatch; /** * ClassName: Test001 * Description: Test001 * Date: 2021-07-01 15:58 * * * @author yufengming * @version 产品版本信息 2021-07-01 15:58 yufengming(victorefengming.gitee.io) 新建 * @project mayikt_zk * @package com.mayikt.zk * @email victorfengming@163.com * * 修改记录 */ public class Test001 { // * 参数1. 链接地址 private static final String ADDRES = \"116.62.194.162:2181\"; // * 参数2. zk超时事件 private static final int TIMEOUT = 5000; // * 参数3. 事件通知 // // countDownLatch计数器 private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) throws IOException, KeeperException, InterruptedException { // zk 核心节点 + 事件通知 // 节点路径 和节点 value /** * 参数1. 链接地址 * 参数2. zk超时事件 * 参数3. 事件通知 */ // 1. 创建 zk链接 ZooKeeper zooKeeper = new ZooKeeper(ADDRES, TIMEOUT, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { Event.KeeperState state = watchedEvent.getState(); if (state == Event.KeeperState.SyncConnected) { System.out.println(\"zk链接成功!!!\"); // 计数器减一 countDownLatch.countDown(); } } }); System.out.println(\"zk 正在链接等待...\"); // 计数器 结果必须为0 才能继续执行 countDownLatch.await(); System.out.println(\"开始创建节点\"); // 2. 创建我门的节点 // 参数1 路径名称 // 参数2 节点value // 参数3. 节点权限 acl OPEN_ACL_UNSAFE 开放权限 // 参数4 节点类型 临时和永久 String s = zooKeeper.create(\"/mayikt2\", \"mayikt2_content\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); System.out.println(s); // } } 08.Zookeeper四种节点类型.mp4 String s = zooKeeper.create(\"/mayikt3\", \"mayikt3_content\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); zk 正在链接等待... zk链接成功!!! 开始创建节点 /mayikt3 Process finished with exit code 0 会发现 - 创建完了没有 节点数据 , 就离谱 因为我这个会话已经关闭了 你如果有想要看到效果你可以搞一个等待 Thread.sleep(5000); 就能看到一瞬间 然后就 /** * zk 节点分为4种类型 * 1. 临时节点 - 会话关闭就没了 CreateMode.EPHEMERAL * 2. 持久节点 - 存到硬盘中,它不没 CreateMode.PERSISTENT * 3. 临时有序号节点 CreateMode.EPHEMERAL_SEQUENTIAL * 4. 持久有序号节点 CreateMode.PERSISTENT_SEQUENTIAL */ 不能直接创建 多级别 节点 String s = zooKeeper.create(\"/victor/s1\", \"content1\".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL); System.out.println(s); zk 正在链接等待... zk链接成功!!! 开始创建节点 Exception in thread \"main\" org.apache.zookeeper.KeeperException$NoNodeException: KeeperErrorCode = NoNode for /victor/s1 at org.apache.zookeeper.KeeperException.create(KeeperException.java:111) at org.apache.zookeeper.KeeperException.create(KeeperException.java:51) at org.apache.zookeeper.ZooKeeper.create(ZooKeeper.java:783) at com.mayikt.zk.Test001.main(Test001.java:68) Process finished with exit code 1 acl权限 我们之前创建的 权限 是都可以访问的 09.Zookeeper节点ACL权限控制.mp4 package com.mayikt.zk; import org.apache.zookeeper.*; import org.apache.zookeeper.data.ACL; import org.apache.zookeeper.data.Id; import org.apache.zookeeper.server.auth.DigestAuthenticationProvider; import java.io.IOException; import java.security.NoSuchAlgorithmException; import java.util.ArrayList; import java.util.concurrent.CountDownLatch; /** * ClassName: Test001 * Description: Test001 * Date: 2021-07-01 15:58 * * * @author yufengming * @version 产品版本信息 2021-07-01 15:58 yufengming(victorefengming.gitee.io) 新建 * @project mayikt_zk * @package com.mayikt.zk * @email victorfengming@163.com * * 修改记录 */ public class Test002 { // * 参数1. 链接地址 private static final String ADDRES = \"116.62.194.162:2181\"; // * 参数2. zk超时事件 private static final int TIMEOUT = 5000; // * 参数3. 事件通知 // countDownLatch计数器 private static CountDownLatch countDownLatch = new CountDownLatch(1); public static void main(String[] args) throws IOException, KeeperException, InterruptedException, NoSuchAlgorithmException { // zk 核心节点 + 事件通知 // 节点路径 和节点 value /** * 参数1. 链接地址 * 参数2. zk超时事件 * 参数3. 事件通知 */ // 1. 创建 zk链接 ZooKeeper zooKeeper = new ZooKeeper(ADDRES, TIMEOUT, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { Event.KeeperState state = watchedEvent.getState(); if (state == Event.KeeperState.SyncConnected) { System.out.println(\"zk链接成功!!!\"); // 计数器减一 countDownLatch.countDown(); } } }); System.out.println(\"zk 正在链接等待...\"); // 计数器 结果必须为0 才能继续执行 countDownLatch.await(); System.out.println(\"开始创建节点\"); // 1.2 .创建账号权限 admin可以实现读写操作 Id id1 = new Id(\"digest\", DigestAuthenticationProvider.generateDigest(\"admin:admin123\")); ACL acl1 = new ACL(ZooDefs.Perms.ALL, id1); // 3.创建权限guest 只允许做读操作 Id id2 = new Id(\"digest\", DigestAuthenticationProvider.generateDigest(\"guest:guest123\")); ACL acl2 = new ACL(ZooDefs.Perms.READ, id2); // 4.添加该账号 ArrayList aces = new ArrayList(); aces.add(acl1); aces.add(acl2); // 2. 创建我门的节点 // 参数1 路径名称 // 参数2 节点value // 参数3. 节点权限 acl OPEN_ACL_UNSAFE 开放权限 // 参数4 节点类型 临时和永久 String s = zooKeeper.create(\"/meite\", \"content\".getBytes(), aces, CreateMode.PERSISTENT); System.out.println(s); } } 但是 meite下面没有值,因为没有权限查看 10.使用Zookeeper实现服务注册.mp4 11.使用Zookeeper实现服务发现.mp4new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-07-01 16:59:48 "},"meite/02_基于Zookeeper实现分布式锁/":{"url":"meite/02_基于Zookeeper实现分布式锁/","title":"02_基于Zookeeper实现分布式锁","keywords":"","body":"01.第一节-Zookeeper基础知识点回顾.mp402.第二节-Zookeeper实现事件监听通知.mp403.第三节-多线程情况下生成订单号码存在那些问题.mp404.第四节-Zookeeper实现分布式锁基本设计思路.mp405.第五节-使用模版方法设计模式定义共同锁骨架.mp406.第六节-Zookeeper实现分布式锁代码实现.mp407.第七节-Zookeeper效果整体演示.mp408.第八节-Zookeeper超时了，如何防止死锁问题.mp409.第九节-Zookeeper实现分布式锁事件移出.mp4$1mp4\\n\\n\\n\\n01.第一节-Zookeeper基础知识点回顾.mp4 zk 实现基本的总结 类似于文件系统存储 可以帮助我们解决分布式领域中遇到的问题 zk分布式协调工具 特征: 定义的节点包含key(路径) 和 value,路径允许有重复, 保证唯一性 zk分为4种类型, 持久,持久序号,临时,临时序号 持久于临时节点区别: 连接如果一旦关闭,当前的节点自动删除; 事件通知: 监听节点发生的变化, 删除 ,修改, 最核心:事件通知 和 临时节点 02.第二节-Zookeeper实现事件监听通知.mp4 9:58 监听节点,可以拿到子节点的结果 从而可以更新 服务列表 03.第三节-多线程情况下生成订单号码存在那些问题.mp4 04.第四节-Zookeeper实现分布式锁基本设计思路.mp4 05.第五节-使用模版方法设计模式定义共同锁骨架.mp4 06.第六节-Zookeeper实现分布式锁代码实现.mp4 07.第七节-Zookeeper效果整体演示.mp4 08.第八节-Zookeeper超时了，如何防止死锁问题.mp4 09.第九节-Zookeeper实现分布式锁事件移出.mp4 ``` (.*)mp4\\n $1mp4\\n\\n\\n\\n ```new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-07-02 14:57:37 "},"meite/03_Zookeeper集群环境搭建/":{"url":"meite/03_Zookeeper集群环境搭建/","title":"03_Zookeeper集群环境搭建","keywords":"","body":"01.Zookeeper集群选举效果演示.mp402.分布式理论强一致性概念.mp403.分布式理论最终一致性概念.mp404.生活案例实际讲解一致性原理.mp405.Zookeeper集群选举原理策略.mp406.构建Zookeeper集群环境01.mp407.构建Zookeeper集群环境02.mp408.为什么Zookeeper集群节点一定要是奇数.mp401.Zookeeper集群选举效果演示.mp4 zk集群 强制一致性,弱一致性,最终一致性 概念 分区容错CAP概念,为什么不能三者全部兼容 zk一致性zab协议底层原理 为什么zk集群节点一定要是奇数 zk集群节点最好是奇数, 基本规则,剩余节点的总数大于(n) 集群节点总数/2 ,zk才可以正常运行 n = 3,宕机了1台,整个集群可以运行 02.分布式理论强一致性概念.mp4 mysql集群 表结构都相同 强一致性概念: 也就是步骤1修改了userName为mayitk,布置一定读取到结果也是为mayitk; 实现方式: mysql主从复制 非常迅速同步或者是使用锁机制必须等待mysql1数据同步到mysql2 这时候才可以读取 03.分布式理论最终一致性概念.mp4 注意: 在分布式中不可能保证强一致性 弱一致性: 也就是步骤1修改了 userName 为 mayikt,允许步骤2 读取时候 还是原来数据; 最终一致性: 在弱一致性的情况下进行优化,允许步骤2进行脏堵,最终要进行同步(重试/人工补偿) 04.生活案例实际讲解一致性原理.mp4 超过一半的反馈 原理: 投票过半机制,zk选举策略领导就采用过半机制 预提交（你们是否听懂>?）等待你们回复过半的学员都听懂的话执行下一步流程 2pc两阶段提交协议; I 过程中存在:预提交、接受回复执行请求类似2PC两阶段提交过半机制 05.Zookeeper集群选举原理策略.mp4 04:19 06.构建Zookeeper集群环境01.mp4 07.构建Zookeeper集群环境02.mp4 08.为什么Zookeeper集群节点一定要是奇数.mp4 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-07-02 16:53:24 "},"meite/04_Zookeeper一致性原理/":{"url":"meite/04_Zookeeper一致性原理/","title":"04_Zookeeper一致性原理","keywords":"","body":"01.Zookeeper集群可能会存在的问题.mp402.Zk集群使用Observer实现扩展.mp403.如何在Zk集群配置ObServer.mp404.Zookeeper客户端连接集群地址.mp405.ZAB原子广播协议两种模型.mp406.Zookeeper集群解决数据一致性原理.mp407.Zookeeper集群策略zxid的作用.mp408.分布式情况下网络抖动脑裂概念.mp409.分布式架构中CAP与Base理论.mp410.Eureka与Zk作为注册中心区别.mp4敏捷开发01.Zookeeper集群可能会存在的问题.mp4 zk 集群中存在的一些问题 每个节点数据一致性同步问题 zk如何解决分布式一致性问题 ZAB协议底层两阶段提交协议 后期扩展新增 zk 节点需要注意的问题 02.Zk集群使用Observer实现扩展.mp4 首先在Zookeeper 中分为三种角色:。 Leader(领导)Zookeeper集群中的主节点、负责写的请求操作;。 Follower(跟随者）是领导(Leader)角色根随着，出读取操作还可以实现对Leader提议与选举 0bserver如果后期当我们在扩展ZK集群节点时如果角色为Follower越来越多会导致 选举的时间越来越长，所以Observer角色和Follower角色很相似，只是obServer不能够参与Leader角色选举; 增加obServer_的作用主要不影响原来本身选举的时间效率、目的是提高客户端读的请求效率; 原来本身只有3台节点 1个leader 2个follower 剩余来台Follower从新选举 后期新增了2台Follower,总共变成了五台节点 剩余4台Follower从新选举 如果我们后期 zk节点 做扩容的时候 ,如果有节点 的类型 为Follower 类型,可能会导致选举时间越来越长 有可能会造成 整个zk环境不可使用; 注意事项: zk集群在后期扩容的时候,建议不要使用Follower节点类型,因为可能会导致选举 变长: zk 中分为 3种节点: Leader类型 领导类型 负责写的请求,和各个节点同步; Follower类型 跟随者 中心化: 去中心化 02zk是哟概念Ob...扩展 11:21 03.如何在Zk集群配置ObServer.mp4 04.Zookeeper客户端连接集群地址.mp4 05.ZAB原子广播协议两种模型.mp4 06.Zookeeper集群解决数据一致性原理.mp4 07.Zookeeper集群策略zxid的作用.mp4 08.分布式情况下网络抖动脑裂概念.mp4 09.分布式架构中CAP与Base理论.mp4 10.Eureka与Zk作为注册中心区别.mp4 11.Zookeeper集群课后疑问.mp4 敏捷开发 拆分大功能 开会,立会 写代码,跑测试用例,提交,CI/CD,CodeReview,代码评审 new Valine({el: \"#vcomments\",appId: 'CHjATxRcQrXst8eJrdwX0vjz-gzGzoHsz',appKey: 'nWerbwV2WMAxOEmAMkJKvXzs',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) victorfengming.gitee.io，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2021-07-05 10:15:20 "}}